# 线程池的使用
1. 在任务与执行策略之间的隐性耦合
    - 依赖性任务： 如果提交给线程池的任务需要依赖其他的任务，那么久隐含地执行策略带来了约束，此时必须小心地维持这些执行策略以避免产生活跃性问题
    - 使用线程封闭机制的任务
    - 对响应时间铭感的任务
    - 使用ThreadLocal的任务： 只有当线程本地值得生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值
只有当任务都是同类型的，并且相互独立时，线程池的性能才能达到最佳(java 8中有一个ComplatableFuture能够让多个线程协同工作的更好)。如果将运行时间较长的域运行时间较短的任务混合在一起，那么除非线程池非常大，否则可能造成“拥塞”，如果提交的任务依赖于其他的任务，还有可能会造成死锁的问题
    1.1 线程饥饿死锁（Thread Starvation Deadlock）
在单线程的Executor中，如果一个任务将另一个额任务提交到同一个Executore,并且等待这个被提交任务的结果，那么通常会引发死锁（第二个任务停留在工作队列中，并等待第一个任务完成，而第一个任务又无法完成，因为它等待第二个任务的完成），这种现象就被称之为线程饥饿死锁
    1.2 运行时间较长的任务
如果线程池中线程的数量远小于在稳定状态下执行时间较长任务的数量，那么到最后可能所有的线程都会运行这些执行时间较长的任务，从而影响整体的响应性，一般针对这种问题，我们可以使用限时任务等待资源的时间，而不要无限制的等待
2. 设置线程池的大小
    1.Runtime.getRuntime().availableProcessors()：动态的获取线程数
    2.如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源，如果线程池过小，那么僵导致许多空闲的处理器无法执行工作，从而降低吞吐量。
    3.正确设置线程池的大小，必须分析计算环境、资源预算和任务特性。在系统中有多少个CPU?多大的内存？任务是计算密集型、IO密集型还是二者皆可？他们是否需要像JDBC连接这样的稀缺资源？如果需要执行不同类型的任务，并且他们之间的欣慰相差很大，那么应该考虑使用多个线程池，从而使么个线程池可以根据各自的工作负载来调整
    4.对于计算密集型的任务，在拥有N个处理器的系统上，当线程次的大小为N+1时，通常能实现最有的利用率；对于包含IO操作或者其他阻塞操作的任务，由于线程不会一直执行，因此线程池的规模应该更大；
 3. 配置ThreadPoolExecutor
 ```java 
 public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
 ``` 
corePoolSize: 在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程
maximumPoolSize: 表示可同时活动的线程数量的上限，如果某个线程的空闲时间超过了存活时间，那么就会被标记为可回收的，并且当线程池的
大小超过了corePoolSize，那么这个线程就会被终止。
keepAliveTime: 线程池中超过corePoolSize的线程最大存货实现
workQueue: 存放线程的队列
threadFactory: 当需要创建一个新的线程的时候的线程创建工厂
handler: 当workQueue是有界队列，并且被填满后，才开始发挥作用的饱和策略

**管理任务队列：**
    1. 如果新请求的到达速率超过了线程池的处理速率，那么闲到来的请求将累积起来，在线程池中，这些请求会再一个由Executor管理的Runnable队列中等待，
