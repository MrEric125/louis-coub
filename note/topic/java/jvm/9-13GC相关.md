### 垃圾回收
#### 垃圾判定标准
##### 引用计数器

##### 可达性分析

##### 引用类型

对象在堆上创建之后所持有的引用其实是一种变量类型，引用之间可以通过赋值构成一条引用链。从GC Roots 开始遍历，判断引用是否可达。引用的可达性是判断能否被垃圾回收的基本条件。JVMM 会据此自动管
理内存的分配与回收，不需要开发工程师干预。但在某些场景下，即使引用可达，也
希望能够根据语义的强弱进行有选择的回收，以保证系统的正常运行。根据引用类型
语义的强弱来决定垃圾回收的阶段，我们可以把引用分为**强引 用、软引用、弱引用和
虚引用**四类。后三类引用，本质上是可以让开发工程师通过代码方式来决定对象的垃
圾回收时机。我们先简要了解一下这四类引用。

1. **强引用， 即S trong Reference **， 最为常见。如Object o均ect = new O均ect（）；这样的变量声明和定义就会产生对该对象的强引用。只要对象有强引用指向，并且GC Roots可达，那么Java 内存回收时，即使濒临内存耗尽，也不会回收该对象。

2. **软引用， 即So ft Reference** ， 引用力度弱于“强引用”，是用在非必须对象的场景
   在即将OOM 之前，垃圾回收器会把这些软引用指向的对象加入回收范围，以获得更
   多的内存空间，让程序能够继续健康运行。主要用来缓存服务器中间计算结果及不需
   要实时保存的用户行为等。

3. **弱引用， 即Weak Reference** ， 引用强度较前两者更弱，也是用来描述非必需对象
   的。如果弱引用指向的对象只存在弱引用这条线路，则在下一次Young GC 时会被回收。由于YGC 时间的不确定性，弱引用何时被回收也具有不确定性。弱引 用主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象。调用WeakReference.get（）可能返回null ，要注意空指针异常。

4. **虚引用， 即Phantom Reference** ， 是极弱的一种引用关系，定义完成后，就无法
   通过该引用获取指向的对象。为一个对象设置虚引用的**唯一目的就是希望能在这个对**
   **象被回收时收到一个系统通知。虚引用必须与引用队列联合使用**，当垃圾回收时，如
   果发现存在虚引用，就会在回收对象内存前，把这个虚引用加入与之关联的可｜用队列
   中。

除**强引用**外，其他三种引用可以减少对象在生命周期中所占用的内存大小。如果
控制得当，垃圾回收就能够随意地释放这些对象。如果使用了这些引用，就应该像示
例中的seller 一样，为避免强引用劫持，把强引 用置为null ，否则这三种引用就无法
发挥它们的价值。这三者的使用成本是偏大的，开发工程师应该多去考虑如何不造成
内存泄漏，如何提升性能，使方法快速执行完成后形成自然回收。如果这些引用在程
序中使用不当，就会造成更大的风险。

#### 垃圾回收算法
1. 标记清除
2. 标记整理
3. 复制
4. 分代算法
#### 垃圾回收器
1. CMS
2. G1    





[^参考]: 引用类型部分码出高效，ThreadLocal

