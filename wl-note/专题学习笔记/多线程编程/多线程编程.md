# 多线程编程


### 基础知识

1. 进程、线程和任务

   进程（Process）是程序运行实例，是程序向操作系统申请资源(如内存空间和句柄文件)的基本单位

   线程是进程各种可以独立执行的最小单位。例如一个从服务器上下载大文件的程序为了提高执行效率，可能会使用多个线程执行下载任务

   一个进程可以包含多个线程，同一个进程中的所有线程现共享该进程中的资源，如内存空间、文件句柄等，进程与线程之间的关系就好比是一个公司与员工之间的关系，

   线程所要完成的计算被称之为任务，特定线程总是在执行着特定的任务，任务代表线程索要完成的工作，一个任务可以是从服务器上下载一个文件，加压缩一批文件，解压缩一个文件，见识某些文件的修改时间等，

2. 使用多线程的原因

   1. 提高系统吞吐量
   2. 合理利用硬件资源
   3. 避免某个请求对其它请求造成不必要的影响
   4. 提高响应性，最小化对系统资源的使用

3. **可能会遇到的问题**

   1. 线程安全问题
        因为在一个进程中的多个线程会共享该内存中的内存空间，并且是并发运行，因此他们可能会访问或者修改其它线程正在使用的变量。这是把双刃剑，好处是这种方式比其他线程间通行机制更容易实现数据共享，但是同样线程会由于无法预料的数据变化而发生错误，俗称线程不安全。
        
        要编写线程安全的代码，其核心在于要对对象状态访问操作进行管理，特别是对共享的（shared）和可变的（Mutable）状态的访问。共享意味着变量可以由多个线程同时访问，可变意味着变量的值在其生命周期内可以发生变化。
        
        对象的状态是指存储在状态变量（实例变量或者静态变量）中的数据，对象的状态可能包括其他依赖对象的域。
        
        由于不恰当的执行时序而出现不正确的结果，被称之为**竞态条件**（count++的例子：非原子性操作）
        
        当然竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。要避免静态条件问题,就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在状态修改过程中。
        
        **二维表分析法：解释竞态的结果**
        
        状态变量(State Variable):即类的实例变量、竞态变量

        共享变量(Shared variable): 即可以被多个线程共同访问的变量
     
        竞态的两种模式：read-modify-write(读-改-写)、check-then-act(检测而后行动)
     
   2. 线程活性问题，可能会产生活锁或者死锁问题，

      活锁：一个线程一直尝试狗哥操作但是无法进展。
   
      死锁：就是两个锁住的资源接下来分别去获取对方的资源
   
   3. 上下文切换



**线程属性**

![image-20200201222302500](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200201222302500.png)

按照线程是否会组织java虚拟机正常停止，我们可以将java中的线程分为守护线程（Daemon Thread）和用户线程（User Thread）也称之为非守护线程，

线程的daemon属性用于表示相应线程是否为守护线程，用户线程会阻止java虚拟机的正常停止，即一个java虚拟机只有在其所有用户线程都运行结束（Thread.run()调用未结束）的情况下才能正常停止。而守护线程则不会影响java虚拟机的正常停止，即应用程序中有守护线程在运行也不影响java虚拟机的正常停止

**线程层次关系**

假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的子线程，相应的线程A也就被称之为线程B的父线程，线程的这种关系被称之为线程的层次关系

在java平台中，一个线程是否是一个守护线程默认取决于其父线程，默认情况下父线程是守护线程，子线程也是守护线程，父线程是用户线程，子线程也是用户线程,当然父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon()方法，将相应的线程设置为守护线程或者用户线程。

一个线程的优先级默认值为该线程的父线程的优先级，即如果我们没有设置或者更改一个线程的优先级，那么这个线程的优先级的值与父线程的优先级相等，不过遗憾的是，Java  API中并没有提供获取一个线程的父线程或者获取一个线程所有子线程，

习惯上，我们也称某些子线程工作者线程（Worker Thread）或者后台线程（Background Thread）。工作线程通常是其父线程创建来用于专门负责某项特定任务的执行的。

**线程的生命周期**

下图是线程各个状态之间相互转换的示意图

![线程状态转换](..\..\etc\java\线程状态相互转换.png)

线程状态可以通过监控工具查看，也可以通过Thread.getState()调用来获取。对线程进行监视的主要途径是获取并查看程序的线程转储（Thread Dump）一个程序的线程转储包含了获取这个线程转储的那一刻该程序的线程信息，包含了具体的线程属性，生命周期状态，贤臣过的调用栈，以及锁等相关信息

线程监控工具有一下几种

1. jvisualvm
2. jstack
3. JMC
4. kill -3 PID

**串行、并发与并行**

**串行(Sequential)**：也就是彼此之间必须有个先后顺序的执行某些线程工作,对于系统资源而言，对于多个任务，单核从前往后一次处理

**并发(Concurrent):** 投入的也只是核，但是对于执行的多个任务，它是相互交替进行的，这种方式能够很好的提高系统的吞吐量，对于用户而言似乎是多个线程同时在运行，但是对于cpu，每个执行时，是只有一个线程在运行的，但是会有多个线程相互交替运行

**并发(Parallel)**:这才是真正的利用了多核，它能够调用CPU的多核同时执行，

![image-20200202120708026](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200202120708026.png)



**线程安全**

一般而言，如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其适用房不必为其做任何改变的情况下也能够运行正常，那么我们就说这事线程安全的。当我们在使用一个类时，首先我们要关心这个类是否是线程安全的，因为这关系到我们如何正确使用这些类。

一个类如果不是线程安全的，我们就说这个类在多线程环境下的直接使用存在线程安全问题，线程安全问题概括起来可以分为三个方面：**原子性、可见性、有序性**。这也和[JVM内存模型相关](https://gitee.com)

**原子性**

原子(Atomic)的字面意思是不可分割的(Indivisible)。对于设计共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作(简单讲就是这个操作不可以再分割成多个线程操作)，相应的，我们也称这种操作具有原子性。那么不可分割就是指某个操作(读，写)要么全部结束，要么尚未发生。

1. 原子操作时针对访问`共享变量`的操作。也就是说仅仅涉及到`局部变量`访问的操作无所谓是否是原子操作
2. 原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多个线程环境下有意义

Java中有两种方式来实现原子性：

一种是使用锁（Lock）:锁既有排他性，也就它能够保证共享变量在任意时刻只能够被一个线程访问，这就排除了多个线程在同一时刻访问同一个共享变量而导致的干扰和冲突的可能。

另一种是利用处理器提供的专门CAS(Compare an Swap)指令，后面会专门介绍CAS,这里需要简单说明一下，CAS其实也是一种乐观锁，锁类型介绍见[同步机制](#同步机制)

java中 long和double以外的任何基本数据类型的变量的写操作都是原子操作（long 和double的实现都是64位，其他基本类型的实现都是32位）。对于long 和double，java语言规范并不保证其具有原子性，尽管如此，java语言规范还特别规定了[volatile](#volatile)关键字修饰的long/double变量写操作具有原子性。

java语言中针对任何变量的读操作都是原子性的

**可见性**
在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立即读取到这个更新之后的结果，甚至永远也无法读取到这个更新之后的结果，这就是线程安全问题的另一个表现形式，可见性（Visibility）

具体可见性可以参考[JVM内存模型](#JVM内存模型)

**有序性**

有序性(Ordering)指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作子另外一个处理器上运行的其他线程看来是乱序的，

1. 重排序：

   简单说就是编译器可能会改变两个操作的先后顺序，处理器可能不是完全按照程序的目标代码所指定的顺序执行指令，另外一个处理器上执行的多个操作，从其他处理器的角度来看其书序可能与目标代码所指定的顺序不一致，这种现象就叫做重排序

   在java平台中，静态编译器(javac)基本上不会执行指令重排序，而JIT编译器则可能执行指令重排序，

   重排序所具有的两个特征：

   1. 重排序可能导致线程安全问题
   2. 重排序不是必然出现

   **为什么需要对代码进行重排序？**

   ​		现代处理器为了提高指令执行效率，汪汪不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到那条指令就绪就先执行那条指令，这就是处理器的乱序执行，在乱序执行的处理器中，指令时一条一条按照程序顺序被处理器读取的（"顺序读取"），然后这些指令中，哪些就绪了，就先执行哪些指令，而不是完全按照程序顺序执行。这些指令执行的结果（要进行写寄存器或者写内存的操作）会被先存入重排序缓冲器（ROB）,而不是直接被写入执行器或者主内存中，重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交（commit,即写入）到寄存器或则内存中去（顺序提交），在乱序执行的情况下，尽管指令的执行顺序可能没有完全按照程序顺序，但是由于指令的执行结果的提交（反应到寄存器和内存中）任然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响

   ​		处理器的乱序执行还采用了一种被称之为猜测执行（Speculation）的技术，猜测执行技术就是不确定哪条能够通往目的地，但是程序可以凭猜测走其中哪一条，大不了猜错了，掉头重新执行。

   **存储子系统的重排序**

   ​		主内存（RAM）相对于处理器是一个慢速设备，为了避免其拖后腿，处理器并不是直接访问主内存的，而是通过高速缓存（Cache）访问主内存的，在此基础上，现代处理器还引入了写缓冲器（Store Buffer，也成Write Buffer）以提高写高速缓存操作（以实现写主内存）的效率，有的处理器对所有的写主内存的操作都是通过写缓冲器进行的。
   
   ​		即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下，其它处理器对这两个操作的感知顺序任然可能与程序顺序不一致，即这两个操作的执行顺序看起来发生了变化，这种现象被称之为存储子系统重排序，也被称之为内存重排序（Memory  ordering）
   
   ​		指令重排序的重排序对象是指令，它是实实在在地对指令的顺序进行调整，而存储子系统重排序是一种现象而不是一种动作，它并没有整整对指令执行顺序进行调整，而只是造成了一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是内存操作的结果
   
   ​		从处理器的角度来说，读内存操作的实质是从指定的RAM地址加载数据（通过高速缓存加载）到寄存器，因此读内存操作通常被称之为load,写内存操作的实质是将数据（可能作为操作数直接存储在指令中，也可能存储在寄存器中）存储到指令地址表示的RAM存储单元中，因此写内存操作通常被称之为Store。所以，内存重排序实际上只有一下四种可能
   
   ![image-20200203104320916](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200203104320916.png)
   
   ![image-20200203104402029](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200203104402029.png)



**保证内存访问的有顺序性**

其实也就是要么重排序不发生，即使重排序发生了，也不影响多线程程序的正确性

**上下文切换**

单处理器上的多线程是通过一种时间片的分配方式来实现的，时间片决定了一个线程可以连续占用处理器运行的时间长度，当一个进程中的一个线程由于其时间片用完或者其自身的原因（比如，它需要稍后再继续）被迫或者主动暂停其运行时，另外一个线程(可能是同一个进程或者其他进程中的一个线程)可以被操作系统（线程调度器）选中占用处理器开始或者继续其运行，这种一个线程被暂停，即被剥夺处理器的使用权，另外一个线程被选中开始或者继续运行时的过程就交错线程上下文切换。相应的一个线程被剥夺处理器的使用权而被暂停运行被称之为切出（Switch out）一个线程被操作系统选中占用处理器开始或者喜剧其运行被称之为切入（Switch In）

​		在切出时，操作系统需要将上下文保存到内存中，以便被切出的线程稍后占用处理器继续其运行时能够在此基础上进展。在切入时，操作系统需要从内存中加载（恢复）被选中的上下文。

​		一个线程的生命周期状态的变化就是一次上下文切换的过程。

​		由资源稀缺性或者程序自身问题导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象被称之为线程活性故障（Liveness Failure）

常见活性故障包括以下几种：

- 死锁（Deadlock）：
- 锁死(Lockout): 
- 活锁（livelock）:活锁的表现形式就是线程一直处于RUNNABLE状态，但是线程索要执行的任务却丝毫没有进展
- 饥饿（Starvation）:



#### 同步机制

**锁**：将多个线程对共享数据的并发访问转换成串行访问，即一个共享数据一次只能被一个线程访问，该线程访问结束后其他线程才能对其进行访问。

如果有多个线程访问同一个锁所保护的共享数据，那么我们就称这些线程同步在这个锁上，或者称我们对这些线程锁进行的共享数据访问进行了加锁。这些线程锁执行的临界区被称为这个锁所引导的临界区

​		锁具有排他性（Exclusive），即一个锁一次只能被一个线程持有，因此这种锁被称为排它锁或者互斥所（Mutex）。这种锁的实现方式代表了锁的基本原理，

**锁的作用**

1. 锁是通过互斥的方式来保障原子性的。所谓互斥（Mutual Exclusion）就是一个锁一次只能被一个线程持有，因此一个线程持有一个锁的时候，其它线程无法获取该锁，而只能等待其释放该锁后再申请。这就保证了临界区代码一次只能被一个线程执行，

**锁相关的几个概念**

1. 可重入性

   一个线程在其持有一个锁的时候能够再次申请该锁

   实现方式： 可重入锁可以理解为一个对象，该对象包含了一个计数器属性。计数器属性的初始值为0，表示相应的锁还没有被任何线程持有。每次线程获取一个可重入锁的时候，该锁的计数器值就会+1。每次一个线程释放锁的时候，该锁的技术其属性值就会被-1。

2. **锁的争用于调度**

   对锁的调度策略支持公平策略和非公平策略，内部锁（synchronized关键字）属于非公平锁，而显示锁（Lock接口）则既支持非公平策略也支持公平策略

3. **锁粒度**

   一个锁实例可以保护一个或者多个共享数据，一个锁实例所保护的共享数据的数量大小就被称之为锁粒度（Granularity）,一个锁保护的共享数据大，我们称之为粒度粗
   
4. 锁类型

   自旋锁

   公平锁

   非公平锁

   可重入锁

#### 线程之间的协作

#### 线程管理

#### JVM内存模型与多线程编程相关

**内存模型的抽象**

​		在并发编程中，我们需要处理两个关键问题：线程之间如何通信以及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。

​	在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。很显然，共享内存的方式实现起来更简单，java的线程同步方式就是共享内存的方式

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。局部变量，方法定义参数和异常处理器参数，不会再线程之间共享，他们不会有内存可见性问题，也不受内存模型的影响

java线程之间的通信由java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（local memory）,本地内存中存储了该线程以读写共享变量的副本，本地内存是JMM的一个抽象概念，并不真实存在，写缓存去，寄存器以及其他的硬件和编译器优化，java内存模型的抽象示意图

![image-20200209184926484](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209184926484.png)



从上图中可以看出来，线程A与线程B之间如果要通信的话，必须要经历下面两个步骤

1. 线程A把本地内存A中更新过的变量变更刷新到主内存中
2. 线程B到主内存中读取线程A之前已更新过的共享变量

![image-20200209185426341](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209185426341.png)



本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为0。线程A
在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了1。

从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。

**重排序**

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种

1. 编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序，

2. 指令级别并行重排序。现在处理器采用了指令级并行技术（instruction-Level parallelism,ILP）来讲多条指令重叠执行，如果不存在数据以来新，处理器可以改变语句对应机器指令的执行顺序

3. 内存系统的重排序，由于处理器使用缓存和读写缓冲区，这使得架子和存储操作看上去可能是乱序执行的

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

![image-20200209190029806](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209190029806.png)



对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

**处理器重排序与内存屏障指令**

现在的处理器使用写缓冲区来临时保存箱内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待相内存写入数据而产生延迟。通过以批处理的方式刷新写入缓冲区，以及合并写
缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：

![image-20200209193620033](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209193620033.png)

假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下
图所示：

![image-20200209193713048](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209193713048.png)

这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。
从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1->A2，但内存操作实际发生的顺序却是：A2->A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。

**happen-before**

从JDK5开始，java使用新的JSR-133内存模型（本文除非特别说明，针对的都是JSR-133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性，在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这里提到的两个操作即可以再一个线程之内，也可以在不同线程之间

与程序员密切相关的happens-before规则如下

1. 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
2. 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
3. volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
4. 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。
happens-before与JMM的关系如下图所示：

![image-20200209194321771](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200209194321771.png)



如上图所示，一个 happens-before 规则通常对应于多个编译器和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免 java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。



**重排序**

>  这一部分请查看深入理解java内存模型



### JUC 介绍

![juc大纲图](..\..\etc\java\juc\juc-total-full.png)



#### atomic

见[atommic类](../../topic/java/juc/2.atomic&cas.md)

juc 相关操作见topic中JUC



##### 

### 多线程设计模式

多线程设计模式这一块主要参考了《java多线程编程实战设计模式篇》



#### 不可变对象(Immutable Object)

如果存在多个线程并发的修改某个对象的状态或者一个线程访问该对象的状态而另外一个线程视图修改该对象的状态，我们不得不做一些同步访问控制保证数据的一致性，而这些同步访问他控制，如显示锁和CAS操作，都会带来一些额外的性能开销问题，这个时候不可变对象就能够很好的解决这个尴尬局面

所谓不可变对象就是一经创建，，其对外可见的状态就保持不变，例如String、Integer。

一个严格意义上的不可变对象要满足一下所有条件

1. 类本身使用final修饰，防止其子类改变其定义的行为
2. 所有的字段都必须是final修饰的：这样不仅保证了语义上的不可变，更重要的是在多线程环境下由JMM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程可见时，它必须是初始化完成了的
3. 在对象的创建过程中，this关键字没哟泄露给其他类，防止其他类在对象的创建过程中修改其
4. 任何字段，若其应用了其它状态可变的对象，则这些字段必须是private修饰的，并且这些字段值不能对外暴露，如果有方法要返回这些字段值，字段必须要有防御性复制（Defensive Copy）

**Immutable Object 使用场景**

1. 被建模对象的状态变化不频繁，
2. 同事对一组相关的数据进行写操作，因此需要保证原子性
3. 使用某个duixian个作为安全的HashMap的Key

**Immutable Object使用需要注意的事项**

1. 被建模对象的状态变化比较频繁

   这种情况下也不是不可以使用不可变对象模式，只是这样的话就会增加[JVM垃圾回收]()的负担和CPU的消耗，我们需要总和考虑，

2. 使用等效或者近似的不可变对象

   有时候创建严格意义的不可变对象比较麻烦，但是我们可以无限想严格的不可变对象靠拢，这样有利于发挥不可变对象的好处

3. 防御性复制

Immutable Object在java库中的引用，CopyOnWriteArrayList,等等



#### 保护性暂挂(Guarded Suspension)

该设计模式的核心思想是如果某个线程执行特定的操作前需要满足一定的条件，则在该条件未满足时将该线程暂停运行(暂挂线程，使其处于等待（WAITING）状态，知道该条件满足时才继续该线程的运行)

**保护性暂挂的架构**
Guarded suspension 的核心是一个受保护的方法（Guarded method），该方法执行其索要真正的操作时需要满足特定的条件（predicate,即保护条件）当该条件不满足时，执行受保护方法的线程就会被挂起进入等待（Waiting）状态，知道该条件满足时该线程才会继续运行，此时，受保护方法才会整整执行其索要执行的操作。

#### 两阶段终止(Two-phase Termination)
#### 承诺(promise)
#### 生产者消费者(producer-consumer)
#### 主动对象模式(Active Object)
#### 线程池模式(Thread pool)
#### 线程特有存储(Thread Specific Storage)
#### 串行线程封闭(Serial Thread Confinement)
#### 主从模式(Master-Slave)主从模式、
#### 流水线(Pipeline)
#### 半同步半异步(Half-sync/Half-async)

### 分布式项目中多线程编程的思考



参考文献：

[^1]:《java多线程编程实战指南-核心篇》

[^2]:《java多线程编程实战指南-设计模式篇》

[^3]:《深入理解java内存模型》

