JVM是Java程序运行基础，面试时一定会遇到JVM相关的问题，这节课我会先对面试中JVM的考察点进行汇总介绍，然后对JVM内存模型，Java的类加载机制，常用的这些算法这三个知识点进行详细的讲解，最后给出JVM考查点和加分项以及这部分知识的面试真题供你参考，

首先来看JVM的知识点汇总。这部分有六个大方向，内存模型、类加载机制、GC垃圾回收是比较重点的内容。性能调优部分偏重实际应用重点，突出实践能力,编译器优化和执行模式部分偏重理论基础，主要掌握知识点。我们看一下各部分的内容。jvm内存布局部分主要了解程序计数器，方法区，堆栈。本地方法栈的作用保存着哪些数据。类加载部分需要了解双亲委派的加载机制以及常用的类加载器分别加载那种类型的类。GC部分需要了解分代回收的思想和依据，以及不同垃圾回收算法的实现思路和十个场景。性能调优部分的知识点有常用的JVM优化参数的作用参数，调优的依据,要了解常用的JVM分析工具能分析哪类的问题以及使用方法。执行模式部分需要了解解释编译混合模式的优缺点，了解Java7提供的分层编译技术，需要知道jit的即时编译技术和OSR也就是栈上替换，要知道c1、c2两个个编译器针对的场景，其中C2针对的是server模式，优化更激进，在新技术方面可以了解一下Java时提供的由Java实现的groovy编译器。编译优化部分需要了解前端编译器Javac的编译过程，Ast抽象语法树，编译器优化和运行优化。编译优化的常用技术包括公共子表达式的消除，消除方法的内联，逃逸分析，栈上分配，同步消除等。明白了这些，才能写出对编译器友好的代码。JVM的内容相对来说比较集中，但是对知识深度的掌握要求较高，建议课后重点加强

我们来看第一个详解知识点。JVM内存模型主要指运行时的数据区，包括五个部分。栈也叫方法栈是线程私有的线程，线程在执行每个方法是都会同时创建一个栈帧，用来存储局部变量表，操作站，动态连接，方法出口等信息调用方法时执行入栈方法，返回时执行出栈。本地方法栈与栈类似，也是用来保存线程，执行方法时的信息，不同的是执行Java方法时使用的是栈，执行本地方法时使用的是本地方法栈
程序计数器保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器准备执行Java方法服务，执行Native方法时，程序计数器为空。本地方法栈，程序计数器，这三部分都是线程独占的。这三部分都是现成独占的。是GM管理的内存中最大的一块儿。对所有的线程共享，目的是为了存放对象的实例，几乎所有的对象实例都会放在这里，当堆内存没有可用的空间时，会抛出oom异常，根据对象存活的周期，JVM把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。方法区也是各个线程共享的内存区域，又叫非堆区，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器优化后的代码等数据。JDK1.7中的永久代和JDK1.8中的matespace都是方法区的一种实现。面试回答这个问题时就答出两个要点，一个是各部分的功能，另一个是哪些是线程共享的，哪些是线程独占的，JMM是Java内存模型，与刚才讲到的JVM内存模型是两回事，JMM的主要目标是定义程序中变量的访问规则，如图所示，所有的共享变量都存储在主内存中共享，每个线程自己的工作内存，工作内存中保存的是主内存中变量的副本。线程对变量的读写等操作，必须在自己的工作内存中进行，而不能直接读写主内存中的变量。在多线程进行数据交互时，例如线程A给一个共享变量，赋值后有现成必来读取这个值。A修改完变量是修改自己的工作内存区域中，B是不可见的，只有从A地工作内存区写回到主内存B，再从主内存读取到自己的工作区，才能进行进一步的操作。由于指令重排序的存在，这个写读的顺序有可能会被打乱。

因此，JMM需要提供`原子性``可见性``有序性`的保证，我们来看看JMM如何保证原子性，可见性、有序性.
JMM保证最初long和double基础数据类型，它的读写操作是原子性的。另外，关键字`synchronized`也可以提供原则性保证，`synchronized`原子性是通过Java的两个高级字节码指令monitor_Enter和monitor_exit来保证。JMM可见性的保证，一个是通过synchronized，另外一个就是通过volatile,volatile强制变量的赋值会同步刷新回主内存，强制变量的读取会从主内存中重新加载，保证不同的线程总是能够看到该变量的最新值。
JMM有序性的保证，主要通过网络和一系列的happen before原则。`volatile`另一个作用就是阻止指令重排序这样就可以保证变量读写的有序性。happen before原则包括一系列规则比如程序顺序原则就是一个线程内必须保证与一串行性。锁规则就是对同一把锁的解锁一定要发生在再次加速之前此外还包括happen before原则的传递性性
线程的启动，中断中止规则的
第二个详解，知识点是Java的类加载机制类的加载是指将编译好的class类文件中的字节码读入到内存中，将其放在方法区内被创建对应的class对象类的加载分为加载、链接、初始化，其中链接又包括验证，准备、解析三部，看图中上半部，深绿色的部分，我们逐个解析。加载是文件到内存的过程，通过类的完全限定名查找此类字节码文件，并利用自己码文件创建一个class对象，验证是对内文件内容验证，目的在于确保class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全。主要包括四种：文件格式，验证元数据，验证自己码验证符号引用验证准备阶段是进行内存分配为类变量也就是类中static修饰的变量分配内存，并设置初始值，这里要注意初始值是零和null，而不是代码中设置的具体值，代码中设置的值在初始化阶段完成。另外，这里也不包含final修饰的静态变量，因为final变量在编译时就已经分配了。解析主要是解析字段接口，方法主要是将常量池中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或者相对偏移量的。最后是初始化，主要完成静态块儿执行与静态变量的赋值，这是类加载最后阶段，若被加载类的父类没有初始化的，先对父类进行初始化。只有对类的主动使用时才会进行初始化，初始化的触发条件包括创建类的实例的时候。访问类的静态方法或者静态变量的时候，使用Classforname反射累的时候。或者某个字，那被初始化的时候。图中下方浅绿的两个部分表示类的生命周期就是从类的加载到类的实例的创建与使用，再到类对象不再被使用，可以被GC回收，这里要注意一点，由Java虚拟机自带的三种类加载器加载的类，在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义类加载器所加载的类才可以被卸载，接下来我们学习不同的类加载器。java自带的三种类加载器

===
这三种类加载器分别是bootstrap启动类，加载器，扩展类，加载器，应用加载器，系统图，右边的橘黄色文字表示，个类加载器对应的家长公路启动类加载器加载Java后母中立目录下的类。快点进来气，否则加载exe目录下的类应用加载器加载class path指定目录下的累，除此之外还可以自定义类加载器。Java的类加载寻双亲委派模式，即一个类加载器，在加载类时，先把这个请求委托给自己的父类加载继续执行，如果父类加载器还是在负责加载起，就继续向上委托，直到顶层的启动类加载器，如图中蓝色向上的箭头。如果父类加载器能够完成类的加载就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载如图中黄色向下的箭头，这种双亲委派模式的好处，一是可以避免类的重复加载，另外也避免了Java的核心API被篡改。前面提到过Java的堆内存备份带管理，为什么要分开管理，存在管理主要是为了方便垃圾回收，这样做是基于两个事实，第一是大部分对象很快就不再使用了，第二是还有一部分不会立即无用，但也不会持续很长时间，虚拟机中划分为年轻代，老年代和永久带，我们来看图，年轻带主要用来存放新创建的对象，年轻带分为a区和两个survivor区，大部分对象在安全区中生成，当癌症去买时，还存活的对象会在两个survivor区交替保存，达到一定次数后，对象会晋升到老年代。老年代用来存放从年轻戴晋升而来的存活时间较长的对象。永久袋前面也介绍过主要保存类信息等内容，这里的永久带试纸对象划分方式不是专职1.7的破魔generation或者1.8之后的max space。根据年轻待遇老年代的特点，JM提供了不同的垃圾回收算法，垃圾回收算法按类型可以分为引用计数法，复制法，标记清楚法几种，集中营计数法是通过对象被引用的次数来确定对象是否还在被使用，缺点是无法解决循环引用的问题。复制算法需要from和to2块大小相同的内存空间。对象分配时只在from框中进行维修时，把存活对象复制到拓宽中，并清空方块儿，然后交换两块儿分工，把ROM块儿作为突破，把土块儿作为缺点是内存使用率较低，标记清楚，算法分为标记对象和清除不再使用的对象，两个阶段标记，清除算法的缺点是会产生内存碎片，JM中提供的年轻代回收算法，Sierra都是复制算法

而CMSJJC都属于标记清楚算法。下面我们详细介绍几个典型的垃圾回收算法。现在看CMS回收算法。咱们SJDK一点儿寄钱，可以说最主流的垃圾回收算法。CMS，寻标记清楚算法优点是并发手机停顿，想我们看图中CMS的处理过程，CMS的第一个阶段是初始标记，这个阶段会stopped word标记的对象，只是从ruud及最直接可达的对象，第二个阶段是并发标记，这时GC线程应用线程并发执行，主要是标记可达的对象。第三个阶段是重新标记阶段，这个阶段是第二个stop的word阶段。停顿时间比并发标记要小很多，但比初始标记商场主要对对象进行重新扫描，并标记，第四个阶段是并发清理阶段进行并发的垃圾清理，最后一个阶段是并发重置阶段，为下一次jaycee重置相关数据结构计算法，在JDK1.9后成为了GM的默认垃圾回收算法。第一个特点是保持高回收率的同时，减少停顿记忆算法，取消了队中年轻待遇，老年代的物理划分，但她仍然属于分带手机气。计算法将对分为若干个区域成为regent如图中的小方格琐事，一部分区域用作年轻带，一部分用在老年代，还有另外一种专门用来存储巨型对象的分区记忆，和CMS一样会遍历全部对象，然后标记对象引用情况，再清楚对象后会对区域进行复制移动，整合碎片空间。图的右边是这一年清代与老年代的回收过程。这一整年清代回收采用复制算法并行进行收集，收集过程会死到普洱。记得老年代回收同时也会对年轻一代进行回收，主要分为四个阶段。第一个阶段依然是初始标记阶段，完成对跟对象的标记，这个过程是四大不足二的。第二个阶段并发标记阶段，这个阶段适合用户线程并行执行的。第三个阶段，最终标记阶段完成三色标记的标记周期。第四阶段复制清楚阶段，这个阶段会优先对可回收空间较大的对阵进行回收

Garbage first，这也是经营名称的由来，这一采用每次只清理一部分，而不是全部region的增量社经历，由此来保证每次这些停段时间不会过长。总结一下这一算法。这部分需要掌握，记忆是逻辑，粉黛不是物理分担，需要知道回收的过程和停顿的阶段，此外，还需要知道的算法允许通过GM参数设置region的大小范围

刘姐，ZC。范围是一到32兆。还可以设置期望的最大值，这些停顿时间等等，如果你有兴趣，也可以对CMS he je使用的三色标记算法进行简单的了解，DGC是最新的JDK1.11种提供的高效垃圾回收算法。JZ针对大队内存设计，可以支持TB级别的对，非常高兴能够做到十毫秒以下的回收停顿时间。这么短的停顿时间，ZC是如何做到的。我们来了解一下JJC的黑科技ZJZ使用的着色指针技术，我们知道64位平台上一个指针可谓是64位。JJC限制最大支持4GB的，对这样选址只需要使用42位，那么会剩下22位就可以用来保存额外的信息，着色指针技术就是利用指针的额外信息，未在指针上对对象进行着色标记，第二个特点，使用读屏障，JZ使用读屏障来解决GC线程和应用，线程可能并发修改

对象状态的问题，而不是简单粗暴的通过stop的word来做全局的锁定，使用毒屏障，只会在单个对象的处理上有概率被减速，由于毒品的使用进行垃圾回收的大部分时候都是不需要stop的word，因此JZ的大部分时间都是并发处理，这也是ZJC的第三个特点。第四个特点是基于region，这与这一算法一样，不过虽然也分了region，但是并没有进行分摊。JJC的regent不像这一那样是固定大小，而是动态决定认真的大小余震可以动态创建和销毁，这样可以更好地对大对象进行分配管理。第五个特点是压缩整理CMS算法，清理对象时原地回收会存在内存碎片问题。JJC和J一样，也会在回收后对region中的对象进行移动合并，解决了碎片问题，虽然JJC的大部分时间是并发进行，但还是会有短暂的停顿，来看一下JJC的回收过程。这张图是ICC的回收时序绘制的，我们从上往下看。初始状态是整个堆空间被划分为大小不等的许多region及图中绿色的方法开始进行回收时。JJ首先会进行一个短暂的抓捕的word来进行入职跟对象的标记，这个步骤非常短

总数量通常比较小。然后就开始进行并发标记，如图。通过对对象指针进行着色来进行标记，结合读屏障解决单个对象的并发问题，其实这个阶段在最后的时候还会有一个非常短的top的word停顿，用来处理一些边缘情况，这个阶段绝大部分时间都是并发进行的，所以没有明显标识出这个评论，下一个阶段是清理阶段，这个阶段会把标记为不可用的对象进行回收，如图把橘色的不再使用的对象进行了回收，最后一个阶段是重定位，重定位，就是对这些后存活的对象进行移动，腾出大块的内存空间，解决碎片问题。在重庆为最开始，会有一个短暂的stop word。用来重定义集合中的root对象。暂停时间取决于root的数量和重定位及与对象的总活动局的比率，最后是病发重定位，这个过程也是通过读屏障

语音线程并发进行的，总结一下GM相关的面试考察点。首先需要理解JVM的内存模型和Java的内存模型。其次，要了解类的加载过程，了解双亲委派机制。第三，要理解内存的可见性与Java内存模型，对原子性，可见性，有序性的保障机制，第四，要了解常用的这些算法的特点，执行过程和适用场景，例如记忆适合对最大延迟有要求的场合，ZJC适用于64位系统的大内存服务中。要了解常用的GM参数，明白对不同参数的调整会有怎样的影响，适用于什么样的场景，比如垃圾回收的并发数，偏向所得设置等，如果想要面试官对你留下更好的印象的话，注意这些加分项。首先，如果在编译器优化方面有深入的了解的话，会让面试官觉得你对技术深度比较有追求，比如知道在编程时如何利用，战胜分配，降低这些压力，如何编写适合内联优化的代码等等。其次，如果你能有线上实际问题的排查经验或者思路，那就更好了，面试官都喜欢动手能力强的同学。例如，解决过线上经常腹肌C的问题，排查过内存泄漏的问题等等。第三，如果有针对特定场景的GM优化实践或者优化思路，也会有意想不到的效果。针对高并发，低延迟的场景，如何调整这些参数，尽量降低停顿时间，针对队列处理机如何尽可能提高吞吐率等等。如果对最新的GM技术趋势有所了解，也会给面试官留下比较深刻的印象，BC高效的实现原理，了解gravel vm的特点等等，最后给你整理了几道GM相关的面试真题，课后可以重点练习。第一题，Java内存模型前面已经讲过了面试，回答这个问题是记得和面试官确认，是希望回答GM的内存模型，还是Java堆内存访问的模型，不要打跑偏了。第二题要复习一下，什么场景下会触发附近，例如年轻带劲，生食，老年代空间不足，例如永久在空间不足等。后面几题前面已经有过讲解，就不再重复了第七题，忘了他要重点回答强制主内存读写同步以及防止指令重排序两点，比实体要重点介绍强弱软需四种引用以及在这些中的处理方式也是一体，可以了解一下Java自带的几种工具的功能，例如。JMC中飞行记录器堆分析工具，MH线程分析工具和获取的信息的，只卖等等。这节课的内容就到这里，下一刻我会讲解Java中，另一个非常重要的内容，多线程，坚持学习，加油